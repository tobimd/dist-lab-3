UTIL
package util

import (
	"dist/common/log"
	"os"

	"github.com/joho/godotenv"
)

func LoadEnvVariables(f *string, addrMap *map[string]string) {
	err := godotenv.Load()
	log.FailOnError(f, err, "Couldn't load variables from \".env\" at the root of the project")

	for env := range *addrMap {
		(*addrMap)[env] = os.Getenv(env)
	}
}


MOD
module dist

go 1.16

require (
	google.golang.org/grpc v1.36.1
	google.golang.org/protobuf v1.26.0
)

require github.com/joho/godotenv v1.4.0


LOG
package log

import (
	"fmt"
	"log"
	"os"
	"syscall"
)

const (
	LstdAppendFlags = os.O_APPEND | os.O_CREATE | os.O_WRONLY
	LstdLogFlags    = log.LstdFlags | log.Lmicroseconds
)

var (
	fallbackFileName = "unnamed-log"
)

// Print formatted message to stdout as well as to log file
func Print(f *string, msg string, a ...interface{}) {
	log.Printf(fmt.Sprintf(msg, a...))
	Log(f, msg, a...)
}

// Append formatted message to log file
func Log(f *string, msg string, a ...interface{}) {
	if f == nil {
		f = &fallbackFileName
	}

	file, err := os.OpenFile(*f, LstdAppendFlags, 0600)
	FailOnError(f, err, "Couldn't open file \"%s\"", *f)
	defer file.Close()

	logger := log.New(file, "", LstdLogFlags)
	logger.Println(fmt.Sprintf(msg, a...))
}

// If `err` is not `nil`, then follow with Fatal
func FailOnError(f *string, err error, msg string, a ...interface{}) {
	if err != nil {
		Fatal(f, "%s (error:%v)", fmt.Sprintf(msg, a...), err)
	}
}

// Terminate process printing a formatted message to stdout and
// to log file
func Fatal(f *string, msg string, a ...interface{}) {
	Print(f, "[ FATAL ! ] %s", fmt.Sprintf(msg, a...))
	syscall.Exit(1)
}


DATA
package data

// Contains structs, interfaces, reciever functions, constants,
// etc.

var (
	Command = struct {
		ADD_CITY, DELETE_CITY, UPDATE_NAME, UPDATE_NUMBER, GET_NUMBER_REBELS uint8
	}{
		ADD_CITY:          0,
		DELETE_CITY:       1,
		UPDATE_NAME:       2,
		UPDATE_NUMBER:     3,
		GET_NUMBER_REBELS: 4,
	}
)

